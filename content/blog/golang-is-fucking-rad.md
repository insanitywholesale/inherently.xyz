---
title: "Golang Is Fucking Rad"
date: 2021-03-18T21:21:15+02:00
tags: ["golang", "computers", "technology", "programming"]
draft: false
---

## Radical Gopherism
I've been using Go for the better part of a year at this point and I'm loving most things about it.
You know the typical stuff, types, compiled, fast, portable, easy to cross-compile and the rest of the goodness.
However that's not what made me stick with it although those things helped.
The main things I liked were mostly that it was in many ways not like Java.
There is no need for an IDE, the language is not endlessly complex, I can read other people's code right away.
Don't forget the compiler-enforced formatting, easy static compilation allowing for tiny container images.
The standard library is also phenomenal if frameworks are not your cup of tea it's very possible to avoid them in a lot of cases.
And the new file embedding functionality? Amazing, my site is now a portable self-contained binary.
And the adoption? Practically any project I'm interested in just so happens to be written in it!
Most things I use, kubernetes, docker, terraform, vault, gitea, droneci, fluxcd, minio and more I'm probably forgetting.

## Reality
Time to stop drooling though.
While I wasn't inaccurate or misrepresentative above, I want to look at pros-cons for a moment.

### Dank Reality
The main thing I do is write backend web microservices and small operating system utilities.
As mentioned previously, the stdlib is amazing and quite a few things I've written use that almost exclusively.
If web frameworks are needed, there are plenty from piece-by-piece like gorilla, go-kit(depends if you count it) or go-chi, to all-encompassing gargantuan ones like go-micro (ironic name, I know) to middleground solutions like gin-gonic.
I can find client libraries for everything I want be it any sort of api, databases, application messaging systems and recently I found out I can even run ML models generated by keras in python from go.
I didn't harp too much on this before but the static compilation is sweet.
Using docker multi-stage builds and starting from the 150MB fat `golang` image with devtools in it but then being able to run the resulting binary in a run stage based on `scratch` and have a 3MB production image is incredible.
I use it more and more every day and basically haven't looked to shell scripting for anything except heavy string manipulation but even there I'm starting to move as see in [gopasswd](https://git.distro.watch/inherently/gopasswd).

### Sad Reality
This site is my doomer cabin in the woods so the fun stops here.
Also lists are scary so let's *go*
- language package manager: having maintained gentoo ebuilds, I'll never not hate language package managers
- not very competitive alternative compiler: gcc-go produces slower artifacts and I don't want a dotnet situation
- google is very heavily involved: the pkg.go.dev shit just showcased it but I'm not comfortable with google being involved and yes this goes for k8s as well
- grpc support: google came up with grpc and is too involved in go but you need a 3rd party plugin for `protoc` to output go which is stupid
- dev2prod: translating from local to remote dependencies and vice versa is handled poorly
- modules: kinda weird, I've come across too many cases where `rm go.mod go.sum && go mod init && go mod tidy` was needed
- generics: don't want generics but everyone is begging and the advantage of small and understandable might be lost in the future


## Conclusion
Good language, fits what I do, like using it, will continue using it, wish some stuff was improved or fixed.
That was all for this post, I hope you enjoyed.
